---
title: "Professional Précis"
subtitle: "Author: (Jason Gyamfi)"
---

# About the Author

Hello, my name is Jason Gyamfi, and I am looking forward to collaborating with everyone throughout the semester.


# Week 2

## SE1

#### Summary

The book "Software Engineering at Google" talks about the difference between "programming" and "software engineering". People often use these words in the same way, but they mean different things. Students usually learn about computers and then get jobs where they write code. "Software engineering" sounds more detailed, like it uses deeper knowledge, similar to jobs like building planes or bridges. But making software hasn't always been as strict or careful as these jobs. As we use software more in our daily lives, we need to be more careful making it. This book gives tips on how to do that better.

#### Reflection

After reflecting on the preface of this book, I feel that I will gain a different perspective on the world of computer science. I say this because I never realized how the terms "programming" and "software egineering" tie hand and hand. I feel that after reading this book I will learn about the evolution of programming and software egineering and overall gain a better understanding of the two.

#### Use-Case

The information I absored from the topics covered in this reading can apply to the Chasten project in many ways. For one understanding the differences between programming and software engineering will lead us to define roles clearly when working together. Furthermore, the continuous learning aspect of it. Since software engineering is always evolving, as stated in the preface, it will be encouraged for us students to continously update the project.

## FB1

#### Summary

The Fuzzing book's section on software testing offered helpful information. It underlined how testing helps identify and address issues, improving software's stability and dependability. Yet, it also made clear that testing can't promise error-free code. Using an example like the divide-by-zero issue in the square root function, the chapter demonstrated the variation of testing, enhancing my grasp of this key software component.

#### Reflection

After reading and reflecting on this chapter of Fuzzing Book I realized how essential testing is to coding Testing helps you find the very small errors with your code that you may not realize is in your code.

#### Use-Case

The information I learned can be implemented in the chasten project in many ways. For example testing is somethig that will be used in our program in order to check if our codes are running properly.

# Week 3

## SE2

#### Summary

The text explains the differences between making software and just coding. It talks about how long the code will be used and its ability to change with new tech or business needs. Making software involves teamwork and has its own challenges, like organizing the team and setting rules. As a project grows, it needs to work well and grow properly. Making decisions in software is complex, and sometimes you have to choose between not-so-perfect options. A software engineer's job is to aim for long-lasting software and manage the growth of the project.

#### Reflection

This text emphasizes the need for forward-thinking in software creation. The idea is to think about keeping software good for years, not just for a short time, which promotes a flexible approach. Hyrum’s Law shows how developers often use what they see in software, even if it's not a main part. The chapter also talks about the importance of individual learning and sharing what you know. This personal development helps the whole organization move forward.

#### Use-Case

I believe it's crucial when developing software for our project to consider the trade-offs involved. It's essential to understand the advantages and disadvantages of our software before releasing it. We shouldn't release software that has major flaws that could harm our code.

## FB2

#### Summary

The "Code Coverage" section in the Fuzzing book gives a basic understanding of how code coverage works in fuzz testing. It shows how important it is for finding software flaws and gives useful tips on how to use techniques that guide fuzzing with coverage. This part also explains white box and black box testing, which are crucial for making sure software is of high quality. White box testing looks at the code inside, whereas black box testing checks how it works from the outside without knowing the internal details.

#### Reflection

In this section, I learned a lot about how important testing is in creating software. The chapter really focused on the need to test in many different situations, not just on writing the code. It’s about making sure the code works right and can handle different situations. The book also went through different ways to fix problems in the code, and I thought that part was really helpful.

#### Use-Case

For our goal, it's very important to write good test cases to make sure the project stays in great shape for a long time. We have to make testing just as important as making and putting in new code.

# Week 4

## SE3

#### Summary

This chapter points out the importance of teamwork in software engineering at Google, showing that creating software is a team effort. It emphasizes values like being humble, respectful, and trustworthy. While some people believe in the idea of a lone developer, real success in software comes from teams working well together. For software groups to last and do well, they need a strong team-focused culture, not just individual work. This mindset helps teams be creative, take risks, and understand that mistakes happen, all while supporting each other.

#### Reflection


This article really opened my eyes. I've never made software with a team before, so all of this is new to me. Learning about how to work well in a team is helpful

#### Use-Case

The guide discussed in the chapter can be a great tool for our software engineering class, especially during tough projects. It can assist us in building an effective team. For example, if there's a difficult system or method, rather than pushing back against it, we can aim to get it and adjust by collaborating and finding solutions as a team.

## FB3

#### Summary

This chapter explains fuzzing as an effective testing method. Fuzzing means using random or almost random inputs to find problems in software. The chapter goes into detail about different fuzzing methods, like grammar-based and mutation-based fuzzing, and explains important ideas like checking how much code is tested and analyzing crashes. The chapter highlights how using automated tools for fuzzing can help find and use software issues more efficiently.

#### Reflection

The chapter dives deep into different fuzzing methods, like grammar-based and mutation-based fuzzing, giving readers a thorough grasp of this testing method. It also stresses the importance of ideas like how much code is tested and understanding crashes, which are crucial in spotting software problems. The main point of the chapter is the importance of using automated tools for fuzzing to find and fix issues quickly and effectively. This makes the chapter a must-read for those aiming to improve software strength and safety.

#### Use-Case

The chapter gives us deep knowledge about fuzzing, showing its importance in testing. Just as working together is key in software, fuzzing is a great and affordable way to better test our code and find weak spots in our software. We could use this method to test the Chasten program, especially for bugs caused by inputting code or using config files. While this method could be very useful for Chasten, I think it might be even more beneficial later in the semester when we begin working on the Astronaught tool.

# Week 5

## SE4

#### Summary

The main idea of the “Knowledge Sharing” chapter in SE is about how organizations in software engineering work. An organization in this field is essentially a team of engineers and developers working together to build and take care of software. Like in any group, there are hurdles that need to be jumped over to reach success in your project or final objective. Sometimes, software organizations struggle to build a learning environment where everyone feels comfortable admitting what they don’t know in order to learn from their peers. It’s about being willing to share your own gaps in knowledge to benefit from the knowledge of others. You have to be open and share to learn and grow.

#### Reflection

Reading through the chapter made me think about what is needed to create a space where everyone is always learning. You need to make sure that if you don't know something in a particular area, you talk to others and ask for help. This is true for experts in a field as well. As a software engineer, it's crucial to step out of your comfort zone and take on new challenges. You should also be ready to help out and share what you know with others who might not be as far along as you are, whether it's in a specific area or in solving a particular problem.

#### Use-Case

I believe that as a class, we are gradually getting a better grasp of chasten's tools and their functions during its development process. Nevertheless, it's crucial to acknowledge that some of us are progressing faster than others. Those who are more advanced should be willing to share their insights and knowledge. Additionally, when selecting issues to address, it’s vital to diversify our focus. This includes working on problems related to both the source code and the documentation.

## FB4

#### Summary

This section of the Fuzzing book is about mutation analysis, a method of testing that helps us figure out how well a group of test cases can find problems. It checks if the tests can notice small tweaks or mutations in a function’s source code. The book refers to these tweaks as "artificial faults." Here's an example to show what that means:

```python
def triangle_m1(a, b, c):
    if a == b:
        if b == c:
            return 'Equilateral'
        else:
            # return 'Isosceles'
            return None  # <-- injected fault
    else:
        if b == c:
            return "Isosceles"
        else:
            if a == c:
                return "Isosceles"
            else:
                return "Scalene"
```

#### Reflection

The idea of mutation analysis from the Fuzzing Book’s chapter gives us a useful way to see how good our test collections really are. It shows that just looking at how much of the structure the tests cover isn’t enough, as it doesn’t always mean the program’s results will be right. The code samples given, named ineffective_test_1 and ineffective_test_2, clearly show the difference between getting a lot of coverage and actually finding the software’s errors.

#### Use-Case

In chasten, it's crucial to apply the new methods we pick up during this course, whether it’s for writing test cases or handling source code. Our goal should be to create software that’s reliable and free from bugs; the more we can do that, the better. As we go through our textbooks, we should focus on discovering new approaches to tasks and then bring that understanding into our project.

# Week 7

## SE5

#### Summary

The “Engineering for Equity” chapter in the Software Engineering book talks about how important it is to notice and fix bias in software creation. It highlights the need for more variety and acceptance in the field to make sure software is made for all kinds of users. The chapter explains that unintentional bias can hurt groups of people who are not well represented, leading to problems in creating products. For example, it brings up a situation where Google’s picture-identifying technology didn’t take race into account, showing how things can go wrong. The chapter underlines how crucial it is for engineers to learn about and understand different kinds of users and their challenges, and it talks about the need for teams to be culturally diverse. It pushes for a design approach that includes everyone from the start and puts responsibility on engineers to create fair systems. The chapter encourages constant learning and progress, checking how fair systems are, and working with experts in diversity and inclusion to make software that is more inclusive.

#### Reflection

After reading this chapter, I realized that while I haven’t directly faced biases in software, I’ve definitely come across stories and examples of it. Being a software engineer, it’s crucial to understand the significant impact and influence we hold. The tools and software we create can deeply affect a person’s life and feelings based on their interactions with them.

#### Use-Case

Thinking about our chasten project, I notice there’s a bias because the program only supports Python source code at the moment.

## FB5

#### Summary

The "Engineering for Equity" section in the Software Engineering book underlines how crucial it is to notice and fix any bias during the creation of software. It insists on the necessity of having variety and welcoming different people in the field to make software that suits a broad audience. The chapter explains that biases we’re not aware of can accidentally hurt groups that aren’t well-represented, causing products to fail. An example provided is Google’s image recognition technology, which didn’t properly include all races. The chapter urges engineers to pay attention to and understand the different backgrounds and challenges of users, and to create diverse development teams. It promotes designing with everyone in mind from the start and holds engineers accountable for making fair systems. Finally, the chapter pushes for ongoing learning, checking fairness levels, and getting help from experts in diversity and inclusion to develop software that includes everyone.

#### Reflection

The chapter reminds us that it’s both ethically right and practically important to tackle bias and support inclusion in software engineering. It admits that there’s still a lot of work to do before the industry can truly be inclusive and diverse. It urges a change in thinking – instead of making products for everyone, we should be making products with everyone, bringing users into every part of the product development process. It emphasizes that engineers need to think about how their products affect all kinds of users and questions old ways of doing things that put quick results before fairness.

#### Use-Case

While using chasten, I believe tools like integrate and datasette could use mutation-based fuzzing during testing. I've noticed that to execute those commands, you need to provide various file paths, which can be altered or mutated.

# Week 8

## SE6

#### Summary

The "How to Lead a Team" chapter starts by explaining the two different leadership positions: a manager and a tech lead. Both roles are crucial to a team’s success and need to be present at the same time. The chapter also introduces the idea of servant leadership, which aims to foster a culture of humility, respect, and trust, while meeting the needs of the team members and ensuring their well-being. Additionally, the chapter talks about "Antipatterns," which are behaviors and practices that managers should avoid. Examples of these harmful patterns include hiring people who are easy to control and manipulate, overlooking team members who are struggling with their technical work, and neglecting the personal needs of the team.

#### Reflection

Managers and tech leads need different abilities. It's possible to be both. However, a manager typically guides people and organizes plans to complete tasks, while a tech lead takes charge of engineering projects and helps with various software applications. I see myself as a mix of both, but I lean more towards being a tech lead. When I really grasp a topic, I take the lead on engineering tasks and provide assistance with various software applications in that domain.

#### Use-Case

As a group, we have several individuals ready to step up and take on managerial roles at times, and as the semester progresses, more people are becoming comfortable with leading the class. However, we face challenges because we lack a sufficient number of tech leads, and we aren’t all working together in the same space on the project. I believe that if we had class time dedicated to active communication, where everyone could discuss their challenges and share their knowledge, we would be in a much better position.

## FB6

### Summary

This chapter presents the concept of Grammar, a method used to arrange symbols to generate various structured yet random string combinations. This enables us to craft intricate yet manageable string inputs that can be fed into various functions. For instance:

```python
US_PHONE_GRAMMAR: Grammar = {
     "<start>": ["<phone-number>"],
     "<phone-number>": ["(<area>)<exchange>-<line>"],
     "<area>": ["<lead-digit><digit><digit>"],
     "<exchange>": ["<lead-digit><digit><digit>"],
     "<line>": ["<digit><digit><digit><digit>"],
     "<lead-digit>": ["2", "3", "4", "5", "6", "7", "8", "9"],
     "<digit>": ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
}
```

#### Reflection

This section introduces the idea of Grammar, a technique that organizes symbols to create diverse, structured, yet unpredictable combinations of strings. This approach allows us to create complex yet controllable string inputs that can be utilized in numerous functions. As an example:

#### Use-Case

I believe this testing method could be really helpful for the development of Chasten, particularly for testing XPath expressions across various XPath versions. We could create a grammar to produce a range of valid XPath expressions randomly, and then use these to test different XPath parsers.

# Week 9

## SE7

#### Summary

The chapter on Leading at Scale talks about how a person moves from doing tasks alone to leading a team and even more. It looks at how engineers often become leaders of teams and points out that leaders tackle big, less concrete problems. The chapter outlines three main ideas for leaders: Always Be Deciding, which means choosing strategies; Always Be Leaving, which is about making the team work well on its own so the leader isn't the only one who can fix problems; and Always Be Scaling, which is about looking after your own energy and helping the team stand on its own. The key to being a good leader, the chapter says, is to create teams that can operate independently, foster strong leadership, establish good ways of working, and keep a culture of sticking with it over time.

#### Reflection

The chapter describes how an engineer grows into a leadership role, moving away from just technical work to making big decisions and leading a team. It highlights how important it is for leaders to let their team members do things on their own and to not spread themselves too thin, while still helping their team improve. The ideas of Deciding, Leaving, and Scaling are given as a simple guide to being a good leader, showing the shift from just knowing stuff about engineering to running a whole organization. The idea that a leader shouldn't be the only person who can solve problems, but instead should create a team that can keep going on its own, is a strong point. The chapter also talks about how success in leadership means solving problems over and over, facing new issues, and always learning and getting better as a leader.

#### Use-Case

In terms of a use case we as a class have definitely implemented the the three always of leadership.

## FB7

#### Summary

In this part of the fuzzing book, we're improving the ideas from the last chapter about Grammar Fuzzing to make them work better. Before, we were using a method that worked with strings to do fuzzing, but now we're switching to a method that uses a tree-like structure. This tree method helps us keep an eye on how we're expanding elements, letting us track how one element grows into another within the tree. The tree is made up of points called nodes, and each node is connected to another, building up the tree shape.

#### Reflection and Use-Case

In this part of the fuzzing book, we're making improvements to the previous chapter's ideas about Grammar Fuzzing. Instead of using a method that worked with strings, we're now using a method that uses a tree-like structure. This tree method helps us keep track of how one thing turns into another, like tracing how one element grows into another on the tree. Think of the tree as a bunch of connected points, with each point linked to another, building the tree shape. This change makes our fuzzing approach more organized and easier to follow.

# Week 10

## SE8

#### Summary

This chapter from the Software at Google book talks about the importance of having rules and style guides in engineering, with Google as an example. It shows how Google's guidelines are customized for different programming languages, keeping up with changing standards. The chapter also points out the importance of updating rules regularly, as seen in Google's change from CamelCase to snake_case in Python. This shows the need for guidelines that can adapt in a fast-changing engineering world.

#### Reflection

The chapter provides a thorough understanding of the importance of regulations and standards in a large-scale engineering setting. It demonstrates how the foundation of coding practices is made up of strict guidelines and flexible rules that are in line with the objectives and values of the organization.  Clarity and minimization of unnecessary overhead are achieved by concentrating on the development of rules that support certain objectives rather than producing comprehensive rulebooks. In the end, the chapter highlights the crucial role that rules play in creating an engineering environment that is solid to time and scale, allowing for efficient codebase maintenance and fostering a shared development methodology.

#### Use-Case

For Chasten to succeed, policies guaranteeing scalability and adaptability must be put into place. Through regular evaluation, we can modify regulations to accommodate future needs. It's important to keep flexibility and refrain from turning every practice into a strict rule. A good strategy requires that these rules be followed consistently. Whenever possible, making enforcement will streamline the procedure and guarantee that the set practices are followed. By incorporating these ideas into our daily work, we can maintain organization and succeed as a team.

## FB8

#### Summary

The excerpt talks about grammars and their many uses. It says grammars can represent different languages and create sentences in those languages. It also mentions that grammars can take a sentence and break it into its parts, like a puzzle, using a grammar tree. These parts can then be put back together to make new sentences.

#### Reflection and Use-Case

The passage emphasizes that grammars are versatile tools in computer science and language study. They are used to show how languages work and to create text. Breaking down sentences into parts using grammars helps us understand language structure better. Grammars are essential in various fields like natural language processing, making compilers, and analyzing programming languages. We can apply this to Chasten in order to improve code evaluation.

# Week 11

## SE9

#### Summary

This section of Google's software engineering chapter focuses on code review, which is the process of having code reviewed by someone other than the author, usually prior to integration into the codebase. Additionally, the chapter lays out a number of best practices that operate as the foundation of efficient code reviews. As fundamental components that emphasize the value of constructive communication that promotes a pleasant and cooperative environment, politeness and professionalism stand out.

#### Reflection and Use-Case

Google's code review perspective is noteworthy in part because it acknowledges that there is no one-size-fits-all approach to the process. Different methodologies are needed for different types of code reviews, such as greenfield reviews, bug fixes, and refactoring.

## FB9

#### Summary


This chapter highlights a crucial aspect of fuzzing – the potential complexity of generated inputs that can hinder the debugging process. It emphasizes the practicality of automating the reduction and simplification of failure-inducing inputs to enhance the efficiency of debugging efforts. T

#### Reflection and Use-Case

This chapter tackles a frequent fuzzing problem: interpreting produced inputs can be challenging. When debugging, this kind of complexity might become problematic when trying to figure out why a failure happened. The chapter presents methods that automatically reduce  that cause failures in order to lessen this problem. These techniques are meant to simplify and expedite the debugging process.

# Week 12

## SE10

#### Summary

In this part of the fuzzing book, we are getting better at Grammar Fuzzing. We used to work with strings, but now we are using a tree-like structure. This helps us watch how things change from one to another, The tree is just a bunch of connected points, making a tree shape. This switch makes our fuzzing approach more organized and easier to understand.

#### Reflection and Use-Case

This chapter talks about statistical debugging, a way to find program problems by looking at when it fails and when it works. It says that Python can help do this with less code, making it easier for programmers. This reminds us how programming tools are getting better, making it easier to find and fix problems in software. It also shows that understanding how a program behaves is essential in fixing it. This would be very useful in Chasten.

## DB1

#### Summary

In this chapter, we are starting to dive deep into debugging, which involves identifying and fixing bugs in computer software. The focus is on techniques that can automatically provide answers to questions like where a bug is located, when it occurs, and how to resolve it. However, before diving into automating the debugging process, it's essential to have a solid understanding of what debugging entails.

#### Reflection and Use-Case

The chapter on debugging provides a thorough overview, highlighting the importance of using an organized method to troubleshoot coding problems. While some of the material seemed familiar, the emphasis on developing hypotheses and providing thorough evidence sticks out as being crucial. Our team will be much more efficient at debugging if we include these ideas into our debugging approach by promoting hypothesis-driven analysis and thorough documentation.

# Week 13

## SE11

#### Summary

A strong argument is made for the critical role that automated testing plays in the software development life cycle in the chapter "Testing Overview" in the book "Software Engineering at Google." The chapter emphasizes the essential idea that the later in the development process an issue is detected, the more expensive it might become if left unchecked. It presents the idea that businesses with strong testing procedures can quickly adjust to changing market conditions, customer preferences, and technology advancements in addition to preventing bugs from reaching customers.

#### Reflection and Use-Case

The "Testing Overview" chapter essentially asks us to see testing as an important component for navigating the difficulties of software development, rather than just  technical rules and regulations. Teams can avoid errors and establish themselves as flexible and innovative leaders in the rapidly evolving technology industry by including thorough testing procedures and accepting the dynamic nature of the development process.

## DB2

#### Summary

In this chapter, the focus is on observing a program's state while it's running, which is essential for activities like logging and interactive debugging. The chapter emphasizes the efficiency of using Python to achieve this, requiring just a few lines of code to monitor program behavior and gather crucial information.

#### Reflection and Use-Case

This chapter emphasizes the importance of seeing the state of a program while it runs, which is a basic component of debugging and software development. It's interesting that Python's effectiveness in doing this task with little code is mentioned. It emphasizes how developers may now more easily observe program behavior because to the advancements in programming languages and tools. This feature is very helpful for debugging and troubleshooting, giving programmers a better understanding of what their code is doing while it is running.

# Week 14

## SE12

#### Summary

Unit testing is defined in this chapter as an approach that concentrates on testing particular features inside a larger program. Unit tests focus on the smallest functional "units," as opposed to more general testing.

#### Reflection and Use-Case

Because of the many test types, this chapter's extensive insights on test writing could occasionally feel overwhelming. My goal is to get a deeper comprehension and application of these principles, particularly in upcoming scientific computing initiatives. I'll reevaluate how we write tests going forward, trying to divide up complex test cases and stay away from duplication. Instead than making our testing suite slower with excessively many integration tests, we should concentrate on writing clear, effective tests. Our testing in Chasten will be streamlined by incorporating the "Don't Repeat Yourself" idea, guaranteeing concise, effective test cases free of needless duplication.


## DB3

#### Summary

Debuggingbook's "Assertions" chapter explores the use of assertions in software engineering, especially when it comes to debugging and guaranteeing code correctness. As statements that outline specific conditions that are anticipated to hold true at runtime, assertions serve a number of important functions. Assertions automate checks, provide documentation, and facilitate debugging, all of which greatly improve the dependability, maintainability, and efficiency of software systems.

#### Reflection and Use-Case

Comparable to safety checks in computer programming are assertions. They aid with the early detection of errors, the documentation of intended functionality, and the maintenance of dependability and manageability. They serve as a sort of security guard, seeing problems before they become bigger ones. By ensuring that everyone is aware of how the code should behave, they also improve teamwork. Put simply, assertions are essential to maintaining the quality of software. We've already implemented assertions into our chasten tests, and they're working really well.

# Week 15

## DB4

#### Summary

The chapter on Statistical Debugging in the debugging book introduces a method that helps find which lines of code might be causing problems in a program. This technique looks at runs of the program that work and ones that don't, and it tries to find connections between those runs and specific lines of code. It uses a collector function to keep track of which lines of code are used when the program runs with different inputs. Then, it ranks these lines of code based on how often they appear in runs that don't work. This helps identify areas of the code where problems are more likely to occur. By comparing how often different lines are used in runs that work and those that don't, this method can point out suspicious parts of the code, making it easier to find potential issues. Looking at the connection between what happens when the code runs and whether it succeeds or fails is very helpful for debugging, especially when it focuses on the parts of the code that are most often linked to failures. These insights give us important clues about whether specific lines of code are related to program failures, making debugging easier.

#### Reflection and Use-Case

The lessons we've learned show just how vital it is to connect the dots between what we do and what happens next, especially when we're trying to figure out why things go wrong. But I have to admit, I'm a bit uncertain about how smoothly we can incorporate these methods because our project is quite complex. Nevertheless, I'm determined to dive deeper into these techniques and see if we can make them work for our project. I truly believe that if we give them a shot, they could make a big difference in how we pinpoint and fix issues in our programs, making them more dependable in the long run.

























